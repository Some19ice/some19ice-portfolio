<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><title data-next-head="">Building a Real-Time Flood Surveillance System with Satellite Imagery &amp; PostGIS | Blog</title><meta name="description" content="A deep technical dive into architecting a disaster response platform. We explore integrating Google Earth Engine&#x27;s petabyte-scale catalog with FastAPI, PostGIS, and React to predict cholera outbreaks in real-time." data-next-head=""/><link rel="preload" href="/flood-cholera-dashboard.svg" as="image" data-next-head=""/><link rel="preconnect" href="https://opengraph.githubassets.com"/><link rel="dns-prefetch" href="https://api.github.com"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/chunks/6c471d220510bd01.css" as="style"/><script>
                        (function() {
                          try {
                            var localValue = localStorage.getItem('darkMode');
                            if (localValue === 'true' || localValue === null) {
                               document.documentElement.classList.add('dark');
                            } else {
                               document.documentElement.classList.remove('dark');
                            }
                          } catch (e) {}
                        })();
                      </script><link rel="stylesheet" href="/_next/static/chunks/6c471d220510bd01.css" data-n-g=""/><noscript data-n-css=""></noscript><script src="/_next/static/chunks/b913d7483a386423.js" defer=""></script><script src="/_next/static/chunks/204e2614e99eb52b.js" defer=""></script><script src="/_next/static/chunks/89a6e395d8bfe8d0.js" defer=""></script><script src="/_next/static/chunks/15b59a6adf5ea267.js" defer=""></script><script src="/_next/static/chunks/turbopack-69e99bd74a7982bf.js" defer=""></script><script src="/_next/static/chunks/7d576baa31dcb5b4.js" defer=""></script><script src="/_next/static/chunks/025fdbc0eab14052.js" defer=""></script><script src="/_next/static/chunks/55ed861c0b796d1e.js" defer=""></script><script src="/_next/static/chunks/3e330b0113bd23ba.js" defer=""></script><script src="/_next/static/chunks/2198180de92aede7.js" defer=""></script><script src="/_next/static/chunks/turbopack-ee203016ad611a39.js" defer=""></script><script src="/_next/static/cYK4Q_T3OxUO2tdwAEWbj/_ssgManifest.js" defer=""></script><script src="/_next/static/cYK4Q_T3OxUO2tdwAEWbj/_buildManifest.js" defer=""></script></head><body class="font-poppins"><link rel="preload" as="image" href="/flood-cholera-dashboard.svg"/><link rel="preload" as="image" href="https://mermaid.ink/img/pako:eNp1k01v2zAMhv_KoHMToC9F9rBjA7Zhuw7YMOyqwzA0TbW1yJIg06aB_vcpeaRpkTjAAyWKfPjxEilRClWSpfCXKsvht9L64O8c-MHB0d-D88H7QftwMPjeH_QG_cH54Oug1z8YnP4V-jQOQ6fT0dE4tKq29qZUT9W70vpa3WltS_X-XmkbWlVbe1OqD6X1XantV6XtsbW2X5W2w9bavlXaHltL-1lpO2qt7W2l7bC1tF-VtsPW2n5V2h5bS_tVaTtqre13pe2wtbRflbbD1tJ-VdoOW2v7VWl7bC3tV6XtsLW0X5W2w9ba3lXaDltL-1Vpe2yt7Vel7bC1tl-VtsfW0n5V2g5ba_tVaTtqre13pe2wtbRflbbD1tJ-VdoOW2v7VWl7bC3tV6XtsLW2X5W2w9bSflXaDltr-1Vpe2wt7Vel7ai1treVtsPW0n5V2g5ba_tVaXtsLe1Xpe2wtbZflbbD1tJ-VdoOW0v7VWk7aq3td6XtsLW0X5W2w9bSflXaDltr-1Vpe2wt7Vel7bC1tl-VtsPW2n5V2g5bS_tVaTtqre1tpe2wtbRflbbD1tp-VdoOW2v7VWl7bC3tV6XtsLW2X5W2w9bSflXaDltL-1Vp-1drtV39Bw"/><div id="__next"><div class="min-h-screen bg-background text-foreground py-12 px-4 sm:px-6 lg:px-8"><article class="max-w-3xl mx-auto"><a class="inline-flex items-center text-muted-foreground hover:text-primary mb-8 transition-colors" href="/blog"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="mr-2" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg> Back to Blog</a><header class="mb-8"><div class="flex flex-wrap gap-2 mb-4"><div class="inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80">GIS</div><div class="inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80">System Architecture</div><div class="inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80">Google Earth Engine</div><div class="inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80">Python</div><div class="inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80">React</div><div class="inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80">PostGIS</div><div class="inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80">Remote Sensing</div></div><h1 class="text-4xl md:text-5xl font-bold mb-6 leading-tight">Building a Real-Time Flood Surveillance System with Satellite Imagery &amp; PostGIS</h1><div class="flex flex-wrap items-center text-muted-foreground gap-4 md:gap-6 border-b border-border pb-8"><div class="flex items-center"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="mr-2" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2026-01-26</div><div class="flex items-center"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="mr-2" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>20 min read</div></div></header><div class="relative w-full h-64 md:h-96 mb-8 rounded-xl overflow-hidden shadow-lg"><img alt="Building a Real-Time Flood Surveillance System with Satellite Imagery &amp; PostGIS" decoding="async" data-nimg="fill" class="object-cover" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="/flood-cholera-dashboard.svg"/></div><div class="prose dark:prose-invert max-w-none prose-lg"><h1>Building a Real-Time Flood Surveillance System: Where GIS Meets Epidemiology</h1>
<p><strong>Disaster response is fundamentally a data problem.</strong> In regions prone to flooding, the aftermath often brings a secondary, silent killer: <strong>Cholera</strong>. The causal link between rising water levels, contaminated wells, and waterborne disease is well-established, but monitoring this risk in real-time across vast territories like Cross River State requires more than manual reports. It requires <strong>Automated Geospatial Intelligence</strong>.</p>
<p>In this technical case study, I&#x27;ll deconstruct the <strong>Flooding &amp; Cholera Surveillance Dashboard</strong>, a full-stack system I engineered to fuse epidemiological data with real-time satellite imagery. We&#x27;ll look at the architecture, the specific algorithms used for flood detection, and how to optimize a geospatial React application for performance.</p>
<hr/>
<h2>1. The Architecture: Decoupled &amp; Event-Driven</h2>
<p>We needed a system that could ingest massive datasets (satellite imagery) without blocking the user interface. The solution was a decoupled architecture:</p>
<p><img src="https://mermaid.ink/img/pako:eNp1k01v2zAMhv_KoHMToC9F9rBjA7Zhuw7YMOyqwzA0TbW1yJIg06aB_vcpeaRpkTjAAyWKfPjxEilRClWSpfCXKsvht9L64O8c-MHB0d-D88H7QftwMPjeH_QG_cH54Oug1z8YnP4V-jQOQ6fT0dE4tKq29qZUT9W70vpa3WltS_X-XmkbWlVbe1OqD6X1XantV6XtsbW2X5W2w9bavlXaHltL-1lpO2qt7W2l7bC1tF-VtsPW2n5V2h5bS_tVaTtqre13pe2wtbRflbbD1tJ-VdoOW2v7VWl7bC3tV6XtsLW0X5W2w9ba3lXaDltL-1Vpe2yt7Vel7bC1tl-VtsfW0n5V2g5ba_tVaTtqre13pe2wtbRflbbD1tJ-VdoOW2v7VWl7bC3tV6XtsLW2X5W2w9bSflXaDltr-1Vpe2wt7Vel7ai1treVtsPW0n5V2g5ba_tVaXtsLe1Xpe2wtbZflbbD1tJ-VdoOW0v7VWk7aq3td6XtsLW0X5W2w9bSflXaDltr-1Vpe2wt7Vel7bC1tl-VtsPW2n5V2g5bS_tVaTtqre1tpe2wtbRflbbD1tp-VdoOW2v7VWl7bC3tV6XtsLW2X5W2w9bSflXaDltL-1Vp-1drtV39Bw" alt="Architecture Diagram"/></p>
<h3>The Stack</h3>
<ul>
<li><strong>Frontend:</strong> Next.js (React) + Leaflet + Recharts</li>
<li><strong>Backend:</strong> Python (FastAPI) + SQLAlchemy + Pydantic</li>
<li><strong>Database:</strong> PostgreSQL 15 + <strong>PostGIS</strong> extension</li>
<li><strong>Compute Engine:</strong> <strong>Google Earth Engine (GEE)</strong> via Python API</li>
<li><strong>Task Queue:</strong> Background workers for asynchronous data fetching</li>
</ul>
<h3>Why Python &amp; FastAPI?</h3>
<p>While Node.js is excellent for I/O, Python remains the king of geospatial analysis. Libraries like <code>earthengine-api</code>, <code>shapely</code>, and <code>geopandas</code> have no robust equivalents in the JavaScript ecosystem. FastAPI gives us the best of both worlds: the type safety and async performance of modern web frameworks, with full access to the Python data science stack.</p>
<hr/>
<h2>2. Seeing Through Clouds: The Sentinel-1 SAR Pipeline</h2>
<p>One of the biggest ironies in flood monitoring is that <strong>optical satellites are useless when you need them most</strong>. Floods happen during storms, and storms mean clouds. Landsat and Sentinel-2 sensors cannot see through heavy cloud cover.</p>
<p>To solve this, I integrated <strong>Sentinel-1 Synthetic Aperture Radar (SAR)</strong> data. SAR sensors transmit microwave signals that penetrate clouds, rain, and smoke, allowing us to &quot;see&quot; the ground day or night.</p>
<h3>The Algorithm: Change Detection</h3>
<p>Identifying water in SAR imagery isn&#x27;t as simple as &quot;look for blue.&quot; We use a <strong>Change Detection</strong> approach based on backscatter intensity.</p>
<ol>
<li><strong>Baseline Image:</strong> We fetch a median composite of imagery from a dry reference period.</li>
<li><strong>Event Image:</strong> We fetch the latest radar pass during the potential flood window.</li>
<li><strong>Speckle Filtering:</strong> SAR data is noisy (&quot;salt and pepper&quot; effect). We apply a spatial smoothing filter (Boxcar or Refined Lee) to clean the signal.</li>
<li><strong>Thresholding:</strong> Water surfaces act as specular reflectors, bouncing the radar signal away from the sensor. This results in very low backscatter (appearing dark). A significant drop in decibels (dB) between the baseline and event image indicates new water.</li>
</ol>
<p>Here is the core logic implemented in our <code>EarthEngineService</code>:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sar_flood_mapid</span>(<span class="hljs-params">self, geometry, start_date, end_date</span>):
    <span class="hljs-comment"># 1. Select VV and VH polarization (VH is often better for flood detection)</span>
    collection = ee.ImageCollection(<span class="hljs-string">&#x27;COPERNICUS/S1_GRD&#x27;</span>) \
        .filterBounds(geometry) \
        .<span class="hljs-built_in">filter</span>(ee.Filter.listContains(<span class="hljs-string">&#x27;transmitterReceiverPolarisation&#x27;</span>, <span class="hljs-string">&#x27;VH&#x27;</span>)) \
        .<span class="hljs-built_in">filter</span>(ee.Filter.eq(<span class="hljs-string">&#x27;instrumentMode&#x27;</span>, <span class="hljs-string">&#x27;IW&#x27;</span>))

    <span class="hljs-comment"># 2. Define &quot;Before&quot; and &quot;After&quot; periods</span>
    before_collection = collection.filterDate(start_date_ref, end_date_ref)
    after_collection = collection.filterDate(start_date, end_date)

    <span class="hljs-comment"># 3. Mosaic and Filter Speckle</span>
    before = before_collection.mosaic().clip(geometry).focal_mean(radius=<span class="hljs-number">50</span>, units=<span class="hljs-string">&#x27;meters&#x27;</span>)
    after = after_collection.mosaic().clip(geometry).focal_mean(radius=<span class="hljs-number">50</span>, units=<span class="hljs-string">&#x27;meters&#x27;</span>)

    <span class="hljs-comment"># 4. Calculate Difference</span>
    <span class="hljs-comment"># Sentinel-1 data is log-scaled (dB), so subtraction gives the ratio</span>
    difference = after.subtract(before)

    <span class="hljs-comment"># 5. Apply Threshold</span>
    <span class="hljs-comment"># Values &lt; -3dB typically indicate newly submerged land</span>
    threshold = -<span class="hljs-number">3.0</span>
    flood_mask = difference.lt(threshold).selfMask()  <span class="hljs-comment"># selfMask makes 0 values transparent</span>

    <span class="hljs-comment"># 6. Return MapID for frontend tile layer</span>
    <span class="hljs-keyword">return</span> flood_mask.getMapId({<span class="hljs-string">&#x27;min&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;max&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;palette&#x27;</span>: [<span class="hljs-string">&#x27;0000FF&#x27;</span>]})
</code></pre>
<p>By returning a <strong>Tile Layer URL</strong> (<code>https://earthengine.googleapis.com/...</code>) instead of raw data, we offload the rendering heavy-lifting to Google&#x27;s servers. The frontend simply overlays this tile layer on the map, ensuring 60fps performance even with gigabytes of underlying raster data.</p>
<hr/>
<h2>3. Geospatial Risk Modeling with PostGIS</h2>
<p>Identifying the water is only step one. The critical question for disaster response is: <strong>Who is at risk?</strong></p>
<p>We leverage <strong>PostGIS</strong>, the industry-standard spatial extender for PostgreSQL, to answer this. We store:</p>
<ul>
<li><strong>LGA Boundaries:</strong> Administrative regions as <code>MULTIPOLYGON</code> geometries.</li>
<li><strong>Health Facilities:</strong> Clinics and hospitals as <code>POINT</code> geometries.</li>
<li><strong>Cholera History:</strong> Time-series data of cases linked to LGAs.</li>
</ul>
<h3>The Risk Scoring Engine</h3>
<p>When new satellite data comes in, we trigger a risk calculation job. This isn&#x27;t just a simple overlap; it&#x27;s a weighted multi-factor model:</p>
<p>$$ \text{Risk Score} = (w_1 \times \text{FloodExtent}) + (w_2 \times \text{CaseVelocity}) + (w_3 \times \text{Vulnerability}) $$</p>
<p>Where:</p>
<ul>
<li><strong>FloodExtent:</strong> Percentage of the LGA&#x27;s area currently inundated.</li>
<li><strong>CaseVelocity:</strong> Rate of change in new cholera cases over the last 7 days.</li>
<li><strong>Vulnerability:</strong> A static factor based on population density and historical susceptibility.</li>
</ul>
<h3>Spatial SQL in Action</h3>
<p>To calculate the <code>FloodExtent</code>, we don&#x27;t need to download the raster. We can perform vector-raster analysis or use simplified vector intersections if we convert the flood mask to polygons.</p>
<p>Here&#x27;s how we determine which health facilities are in danger zones using PostGIS:</p>
<pre><code class="hljs language-sql"><span class="hljs-comment">-- Find health facilities within 1km of detected flood zones</span>
<span class="hljs-keyword">SELECT</span> 
    hf.name, 
    hf.type,
    lga.name <span class="hljs-keyword">as</span> lga
<span class="hljs-keyword">FROM</span> 
    health_facilities hf
<span class="hljs-keyword">JOIN</span> 
    lgas lga <span class="hljs-keyword">ON</span> hf.lga_id <span class="hljs-operator">=</span> lga.id
<span class="hljs-keyword">WHERE</span> 
    ST_DWithin(
        hf.location, 
        ST_GeomFromGeoJSON(:flood_polygon_json), 
        <span class="hljs-number">1000</span> <span class="hljs-comment">-- meters</span>
    );
</code></pre>
<p>This query runs in milliseconds, allowing us to generate real-time alert lists for field teams.</p>
<hr/>
<h2>4. Frontend Engineering: Performance at Scale</h2>
<p>Visualizing geospatial data on the web is notoriously resource-intensive. We used <strong>Next.js</strong> and <strong>Leaflet</strong>, but encountered several performance bottlenecks during development.</p>
<h3>Challenge 1: Heavy GeoJSON Rendering</h3>
<p>Rendering detailed boundaries for all LGAs caused main-thread blocking.
<strong>Solution:</strong> We simplified the geometries using the <strong>Douglas-Peucker algorithm</strong> (via Mapshaper) to reduce vertex count by 90% without losing visual fidelity at zoom level 8-10. We also implemented <code>useMemo</code> hooks in React to prevent re-parsing the GeoJSON on every render.</p>
<h3>Challenge 2: Dynamic Legend &amp; Symbology</h3>
<p>Users needed to understand the map at a glance.
<strong>Solution:</strong> We implemented a Choropleth layer that dynamically recolors LGA polygons based on the live Risk Score.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Choropleth coloring logic</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getStyle</span>(<span class="hljs-params"><span class="hljs-attr">riskLevel</span>: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">fillColor</span>: riskLevel === <span class="hljs-string">&#x27;high&#x27;</span> ? <span class="hljs-string">&#x27;#ef4444&#x27;</span> : 
               riskLevel === <span class="hljs-string">&#x27;medium&#x27;</span> ? <span class="hljs-string">&#x27;#eab308&#x27;</span> : <span class="hljs-string">&#x27;#22c55e&#x27;</span>,
    <span class="hljs-attr">weight</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;white&#x27;</span>,
    <span class="hljs-attr">fillOpacity</span>: <span class="hljs-number">0.7</span>
  };
}
</code></pre>
<h3>Challenge 3: Time-Travel Analysis</h3>
<p>We built a <strong>Time Slider</strong> component that allows epidemiologists to &quot;replay&quot; the last 90 days. This required synchronizing two disparate data streams:</p>
<ol>
<li><strong>Daily Case Counts:</strong> Fetched from our API.</li>
<li><strong>Satellite Imagery:</strong> Fetched dynamically from GEE.</li>
</ol>
<p>By managing the <code>selectedDate</code> state in a global store (Zustand), we ensure that dragging the slider instantly updates both the chart overlays and the map layers, revealing the lag effect where case spikes often follow flood events by 3-5 days.</p>
<hr/>
<h2>5. Deployment &amp; CI/CD</h2>
<p>The system is containerized with <strong>Docker</strong> for the backend and deployed on Vercel (frontend) and a VPS (backend/DB).</p>
<p>We use <strong>GitHub Actions</strong> for CI/CD, running:</p>
<ul>
<li><strong>Linting:</strong> Ruff (Python) and ESLint (JS).</li>
<li><strong>Type Checking:</strong> Mypy and TypeScript.</li>
<li><strong>Migration Checks:</strong> Alembic is used to manage database schema changes, ensuring our PostGIS extensions and geometry columns are correctly versioned.</li>
</ul>
<h2>Conclusion &amp; Future Work</h2>
<p>This project demonstrates the immense potential of combining <strong>Remote Sensing</strong> with <strong>Modern Web Engineering</strong>. By automating the ingestion and analysis of satellite data, we move from reactive &quot;cleanup&quot; to proactive &quot;early warning.&quot;</p>
<p><strong>What&#x27;s Next?</strong></p>
<ul>
<li><strong>AI Prediction Models:</strong> Training an LSTM neural network on the historical data to predict outbreaks 2 weeks in advance.</li>
<li><strong>SMS Alerts:</strong> Integrating Twilio to send automated SMS warnings to health workers in high-risk LGAs.</li>
<li><strong>Drone Integration:</strong> Allowing field teams to upload drone orthomosaics for hyper-local validation.</li>
</ul>
<p>The stack—<strong>Python, PostGIS, and Google Earth Engine</strong>—has proved to be a robust, scalable foundation for building life-saving geospatial tools.</p>
<hr/>
<p><em>Check out the code on <a href="https://github.com/Some19ice/flooding-cholera">GitHub</a> or view the <a href="https://flooding-cholera.vercel.app">Live Dashboard</a>.</em></p></div></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"building-flood-surveillance-system","content":"\n# Building a Real-Time Flood Surveillance System: Where GIS Meets Epidemiology\n\n**Disaster response is fundamentally a data problem.** In regions prone to flooding, the aftermath often brings a secondary, silent killer: **Cholera**. The causal link between rising water levels, contaminated wells, and waterborne disease is well-established, but monitoring this risk in real-time across vast territories like Cross River State requires more than manual reports. It requires **Automated Geospatial Intelligence**.\n\nIn this technical case study, I'll deconstruct the **Flooding \u0026 Cholera Surveillance Dashboard**, a full-stack system I engineered to fuse epidemiological data with real-time satellite imagery. We'll look at the architecture, the specific algorithms used for flood detection, and how to optimize a geospatial React application for performance.\n\n---\n\n## 1. The Architecture: Decoupled \u0026 Event-Driven\n\nWe needed a system that could ingest massive datasets (satellite imagery) without blocking the user interface. The solution was a decoupled architecture:\n\n![Architecture Diagram](https://mermaid.ink/img/pako:eNp1k01v2zAMhv_KoHMToC9F9rBjA7Zhuw7YMOyqwzA0TbW1yJIg06aB_vcpeaRpkTjAAyWKfPjxEilRClWSpfCXKsvht9L64O8c-MHB0d-D88H7QftwMPjeH_QG_cH54Oug1z8YnP4V-jQOQ6fT0dE4tKq29qZUT9W70vpa3WltS_X-XmkbWlVbe1OqD6X1XantV6XtsbW2X5W2w9bavlXaHltL-1lpO2qt7W2l7bC1tF-VtsPW2n5V2h5bS_tVaTtqre13pe2wtbRflbbD1tJ-VdoOW2v7VWl7bC3tV6XtsLW0X5W2w9ba3lXaDltL-1Vpe2yt7Vel7bC1tl-VtsfW0n5V2g5ba_tVaTtqre13pe2wtbRflbbD1tJ-VdoOW2v7VWl7bC3tV6XtsLW2X5W2w9bSflXaDltr-1Vpe2wt7Vel7ai1treVtsPW0n5V2g5ba_tVaXtsLe1Xpe2wtbZflbbD1tJ-VdoOW0v7VWk7aq3td6XtsLW0X5W2w9bSflXaDltr-1Vpe2wt7Vel7bC1tl-VtsPW2n5V2g5bS_tVaTtqre1tpe2wtbRflbbD1tp-VdoOW2v7VWl7bC3tV6XtsLW2X5W2w9bSflXaDltL-1Vp-1drtV39Bw)\n\n### The Stack\n- **Frontend:** Next.js (React) + Leaflet + Recharts\n- **Backend:** Python (FastAPI) + SQLAlchemy + Pydantic\n- **Database:** PostgreSQL 15 + **PostGIS** extension\n- **Compute Engine:** **Google Earth Engine (GEE)** via Python API\n- **Task Queue:** Background workers for asynchronous data fetching\n\n### Why Python \u0026 FastAPI?\nWhile Node.js is excellent for I/O, Python remains the king of geospatial analysis. Libraries like `earthengine-api`, `shapely`, and `geopandas` have no robust equivalents in the JavaScript ecosystem. FastAPI gives us the best of both worlds: the type safety and async performance of modern web frameworks, with full access to the Python data science stack.\n\n---\n\n## 2. Seeing Through Clouds: The Sentinel-1 SAR Pipeline\n\nOne of the biggest ironies in flood monitoring is that **optical satellites are useless when you need them most**. Floods happen during storms, and storms mean clouds. Landsat and Sentinel-2 sensors cannot see through heavy cloud cover.\n\nTo solve this, I integrated **Sentinel-1 Synthetic Aperture Radar (SAR)** data. SAR sensors transmit microwave signals that penetrate clouds, rain, and smoke, allowing us to \"see\" the ground day or night.\n\n### The Algorithm: Change Detection\n\nIdentifying water in SAR imagery isn't as simple as \"look for blue.\" We use a **Change Detection** approach based on backscatter intensity.\n\n1.  **Baseline Image:** We fetch a median composite of imagery from a dry reference period.\n2.  **Event Image:** We fetch the latest radar pass during the potential flood window.\n3.  **Speckle Filtering:** SAR data is noisy (\"salt and pepper\" effect). We apply a spatial smoothing filter (Boxcar or Refined Lee) to clean the signal.\n4.  **Thresholding:** Water surfaces act as specular reflectors, bouncing the radar signal away from the sensor. This results in very low backscatter (appearing dark). A significant drop in decibels (dB) between the baseline and event image indicates new water.\n\nHere is the core logic implemented in our `EarthEngineService`:\n\n```python\ndef get_sar_flood_mapid(self, geometry, start_date, end_date):\n    # 1. Select VV and VH polarization (VH is often better for flood detection)\n    collection = ee.ImageCollection('COPERNICUS/S1_GRD') \\\n        .filterBounds(geometry) \\\n        .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH')) \\\n        .filter(ee.Filter.eq('instrumentMode', 'IW'))\n\n    # 2. Define \"Before\" and \"After\" periods\n    before_collection = collection.filterDate(start_date_ref, end_date_ref)\n    after_collection = collection.filterDate(start_date, end_date)\n\n    # 3. Mosaic and Filter Speckle\n    before = before_collection.mosaic().clip(geometry).focal_mean(radius=50, units='meters')\n    after = after_collection.mosaic().clip(geometry).focal_mean(radius=50, units='meters')\n\n    # 4. Calculate Difference\n    # Sentinel-1 data is log-scaled (dB), so subtraction gives the ratio\n    difference = after.subtract(before)\n\n    # 5. Apply Threshold\n    # Values \u003c -3dB typically indicate newly submerged land\n    threshold = -3.0\n    flood_mask = difference.lt(threshold).selfMask()  # selfMask makes 0 values transparent\n\n    # 6. Return MapID for frontend tile layer\n    return flood_mask.getMapId({'min': 0, 'max': 1, 'palette': ['0000FF']})\n```\n\nBy returning a **Tile Layer URL** (`https://earthengine.googleapis.com/...`) instead of raw data, we offload the rendering heavy-lifting to Google's servers. The frontend simply overlays this tile layer on the map, ensuring 60fps performance even with gigabytes of underlying raster data.\n\n---\n\n## 3. Geospatial Risk Modeling with PostGIS\n\nIdentifying the water is only step one. The critical question for disaster response is: **Who is at risk?**\n\nWe leverage **PostGIS**, the industry-standard spatial extender for PostgreSQL, to answer this. We store:\n- **LGA Boundaries:** Administrative regions as `MULTIPOLYGON` geometries.\n- **Health Facilities:** Clinics and hospitals as `POINT` geometries.\n- **Cholera History:** Time-series data of cases linked to LGAs.\n\n### The Risk Scoring Engine\n\nWhen new satellite data comes in, we trigger a risk calculation job. This isn't just a simple overlap; it's a weighted multi-factor model:\n\n$$ \\text{Risk Score} = (w_1 \\times \\text{FloodExtent}) + (w_2 \\times \\text{CaseVelocity}) + (w_3 \\times \\text{Vulnerability}) $$\n\nWhere:\n- **FloodExtent:** Percentage of the LGA's area currently inundated.\n- **CaseVelocity:** Rate of change in new cholera cases over the last 7 days.\n- **Vulnerability:** A static factor based on population density and historical susceptibility.\n\n### Spatial SQL in Action\n\nTo calculate the `FloodExtent`, we don't need to download the raster. We can perform vector-raster analysis or use simplified vector intersections if we convert the flood mask to polygons.\n\nHere's how we determine which health facilities are in danger zones using PostGIS:\n\n```sql\n-- Find health facilities within 1km of detected flood zones\nSELECT \n    hf.name, \n    hf.type,\n    lga.name as lga\nFROM \n    health_facilities hf\nJOIN \n    lgas lga ON hf.lga_id = lga.id\nWHERE \n    ST_DWithin(\n        hf.location, \n        ST_GeomFromGeoJSON(:flood_polygon_json), \n        1000 -- meters\n    );\n```\n\nThis query runs in milliseconds, allowing us to generate real-time alert lists for field teams.\n\n---\n\n## 4. Frontend Engineering: Performance at Scale\n\nVisualizing geospatial data on the web is notoriously resource-intensive. We used **Next.js** and **Leaflet**, but encountered several performance bottlenecks during development.\n\n### Challenge 1: Heavy GeoJSON Rendering\nRendering detailed boundaries for all LGAs caused main-thread blocking.\n**Solution:** We simplified the geometries using the **Douglas-Peucker algorithm** (via Mapshaper) to reduce vertex count by 90% without losing visual fidelity at zoom level 8-10. We also implemented `useMemo` hooks in React to prevent re-parsing the GeoJSON on every render.\n\n### Challenge 2: Dynamic Legend \u0026 Symbology\nUsers needed to understand the map at a glance.\n**Solution:** We implemented a Choropleth layer that dynamically recolors LGA polygons based on the live Risk Score.\n\n```typescript\n// Choropleth coloring logic\nfunction getStyle(riskLevel: string) {\n  return {\n    fillColor: riskLevel === 'high' ? '#ef4444' : \n               riskLevel === 'medium' ? '#eab308' : '#22c55e',\n    weight: 2,\n    opacity: 1,\n    color: 'white',\n    fillOpacity: 0.7\n  };\n}\n```\n\n### Challenge 3: Time-Travel Analysis\nWe built a **Time Slider** component that allows epidemiologists to \"replay\" the last 90 days. This required synchronizing two disparate data streams:\n1.  **Daily Case Counts:** Fetched from our API.\n2.  **Satellite Imagery:** Fetched dynamically from GEE.\n\nBy managing the `selectedDate` state in a global store (Zustand), we ensure that dragging the slider instantly updates both the chart overlays and the map layers, revealing the lag effect where case spikes often follow flood events by 3-5 days.\n\n---\n\n## 5. Deployment \u0026 CI/CD\n\nThe system is containerized with **Docker** for the backend and deployed on Vercel (frontend) and a VPS (backend/DB).\n\nWe use **GitHub Actions** for CI/CD, running:\n- **Linting:** Ruff (Python) and ESLint (JS).\n- **Type Checking:** Mypy and TypeScript.\n- **Migration Checks:** Alembic is used to manage database schema changes, ensuring our PostGIS extensions and geometry columns are correctly versioned.\n\n## Conclusion \u0026 Future Work\n\nThis project demonstrates the immense potential of combining **Remote Sensing** with **Modern Web Engineering**. By automating the ingestion and analysis of satellite data, we move from reactive \"cleanup\" to proactive \"early warning.\"\n\n**What's Next?**\n- **AI Prediction Models:** Training an LSTM neural network on the historical data to predict outbreaks 2 weeks in advance.\n- **SMS Alerts:** Integrating Twilio to send automated SMS warnings to health workers in high-risk LGAs.\n- **Drone Integration:** Allowing field teams to upload drone orthomosaics for hyper-local validation.\n\nThe stack—**Python, PostGIS, and Google Earth Engine**—has proved to be a robust, scalable foundation for building life-saving geospatial tools.\n\n---\n\n*Check out the code on [GitHub](https://github.com/Some19ice/flooding-cholera) or view the [Live Dashboard](https://flooding-cholera.vercel.app).*\n","readTime":"20 min read","title":"Building a Real-Time Flood Surveillance System with Satellite Imagery \u0026 PostGIS","date":"2026-01-26","excerpt":"A deep technical dive into architecting a disaster response platform. We explore integrating Google Earth Engine's petabyte-scale catalog with FastAPI, PostGIS, and React to predict cholera outbreaks in real-time.","coverImage":"/flood-cholera-dashboard.svg","tags":["GIS","System Architecture","Google Earth Engine","Python","React","PostGIS","Remote Sensing"]}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"building-flood-surveillance-system"},"buildId":"cYK4Q_T3OxUO2tdwAEWbj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
{"pageProps":{"post":{"slug":"building-flood-surveillance-system","content":"\n# Building a Real-Time Flood Surveillance System: Where GIS Meets Epidemiology\n\n**Disaster response is fundamentally a data problem.** In regions prone to flooding, the aftermath often brings a secondary, silent killer: **Cholera**. The causal link between rising water levels, contaminated wells, and waterborne disease is well-established, but monitoring this risk in real-time across vast territories like Cross River State requires more than manual reports. It requires **Automated Geospatial Intelligence**.\n\nIn this technical case study, I'll deconstruct the **Flooding & Cholera Surveillance Dashboard**, a full-stack system I engineered to fuse epidemiological data with real-time satellite imagery. We'll look at the architecture, the specific algorithms used for flood detection, and how to optimize a geospatial React application for performance.\n\n---\n\n## 1. The Architecture: Decoupled & Event-Driven\n\nWe needed a system that could ingest massive datasets (satellite imagery) without blocking the user interface. The solution was a decoupled architecture:\n\n![Architecture Diagram](https://mermaid.ink/img/pako:eNp1k01v2zAMhv_KoHMToC9F9rBjA7Zhuw7YMOyqwzA0TbW1yJIg06aB_vcpeaRpkTjAAyWKfPjxEilRClWSpfCXKsvht9L64O8c-MHB0d-D88H7QftwMPjeH_QG_cH54Oug1z8YnP4V-jQOQ6fT0dE4tKq29qZUT9W70vpa3WltS_X-XmkbWlVbe1OqD6X1XantV6XtsbW2X5W2w9bavlXaHltL-1lpO2qt7W2l7bC1tF-VtsPW2n5V2h5bS_tVaTtqre13pe2wtbRflbbD1tJ-VdoOW2v7VWl7bC3tV6XtsLW0X5W2w9ba3lXaDltL-1Vpe2yt7Vel7bC1tl-VtsfW0n5V2g5ba_tVaTtqre13pe2wtbRflbbD1tJ-VdoOW2v7VWl7bC3tV6XtsLW2X5W2w9bSflXaDltr-1Vpe2wt7Vel7ai1treVtsPW0n5V2g5ba_tVaXtsLe1Xpe2wtbZflbbD1tJ-VdoOW0v7VWk7aq3td6XtsLW0X5W2w9bSflXaDltr-1Vpe2wt7Vel7bC1tl-VtsPW2n5V2g5bS_tVaTtqre1tpe2wtbRflbbD1tp-VdoOW2v7VWl7bC3tV6XtsLW2X5W2w9bSflXaDltL-1Vp-1drtV39Bw)\n\n### The Stack\n- **Frontend:** Next.js (React) + Leaflet + Recharts\n- **Backend:** Python (FastAPI) + SQLAlchemy + Pydantic\n- **Database:** PostgreSQL 15 + **PostGIS** extension\n- **Compute Engine:** **Google Earth Engine (GEE)** via Python API\n- **Task Queue:** Background workers for asynchronous data fetching\n\n### Why Python & FastAPI?\nWhile Node.js is excellent for I/O, Python remains the king of geospatial analysis. Libraries like `earthengine-api`, `shapely`, and `geopandas` have no robust equivalents in the JavaScript ecosystem. FastAPI gives us the best of both worlds: the type safety and async performance of modern web frameworks, with full access to the Python data science stack.\n\n---\n\n## 2. Seeing Through Clouds: The Sentinel-1 SAR Pipeline\n\nOne of the biggest ironies in flood monitoring is that **optical satellites are useless when you need them most**. Floods happen during storms, and storms mean clouds. Landsat and Sentinel-2 sensors cannot see through heavy cloud cover.\n\nTo solve this, I integrated **Sentinel-1 Synthetic Aperture Radar (SAR)** data. SAR sensors transmit microwave signals that penetrate clouds, rain, and smoke, allowing us to \"see\" the ground day or night.\n\n### The Algorithm: Change Detection\n\nIdentifying water in SAR imagery isn't as simple as \"look for blue.\" We use a **Change Detection** approach based on backscatter intensity.\n\n1.  **Baseline Image:** We fetch a median composite of imagery from a dry reference period.\n2.  **Event Image:** We fetch the latest radar pass during the potential flood window.\n3.  **Speckle Filtering:** SAR data is noisy (\"salt and pepper\" effect). We apply a spatial smoothing filter (Boxcar or Refined Lee) to clean the signal.\n4.  **Thresholding:** Water surfaces act as specular reflectors, bouncing the radar signal away from the sensor. This results in very low backscatter (appearing dark). A significant drop in decibels (dB) between the baseline and event image indicates new water.\n\nHere is the core logic implemented in our `EarthEngineService`:\n\n```python\ndef get_sar_flood_mapid(self, geometry, start_date, end_date):\n    # 1. Select VV and VH polarization (VH is often better for flood detection)\n    collection = ee.ImageCollection('COPERNICUS/S1_GRD') \\\n        .filterBounds(geometry) \\\n        .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH')) \\\n        .filter(ee.Filter.eq('instrumentMode', 'IW'))\n\n    # 2. Define \"Before\" and \"After\" periods\n    before_collection = collection.filterDate(start_date_ref, end_date_ref)\n    after_collection = collection.filterDate(start_date, end_date)\n\n    # 3. Mosaic and Filter Speckle\n    before = before_collection.mosaic().clip(geometry).focal_mean(radius=50, units='meters')\n    after = after_collection.mosaic().clip(geometry).focal_mean(radius=50, units='meters')\n\n    # 4. Calculate Difference\n    # Sentinel-1 data is log-scaled (dB), so subtraction gives the ratio\n    difference = after.subtract(before)\n\n    # 5. Apply Threshold\n    # Values < -3dB typically indicate newly submerged land\n    threshold = -3.0\n    flood_mask = difference.lt(threshold).selfMask()  # selfMask makes 0 values transparent\n\n    # 6. Return MapID for frontend tile layer\n    return flood_mask.getMapId({'min': 0, 'max': 1, 'palette': ['0000FF']})\n```\n\nBy returning a **Tile Layer URL** (`https://earthengine.googleapis.com/...`) instead of raw data, we offload the rendering heavy-lifting to Google's servers. The frontend simply overlays this tile layer on the map, ensuring 60fps performance even with gigabytes of underlying raster data.\n\n---\n\n## 3. Geospatial Risk Modeling with PostGIS\n\nIdentifying the water is only step one. The critical question for disaster response is: **Who is at risk?**\n\nWe leverage **PostGIS**, the industry-standard spatial extender for PostgreSQL, to answer this. We store:\n- **LGA Boundaries:** Administrative regions as `MULTIPOLYGON` geometries.\n- **Health Facilities:** Clinics and hospitals as `POINT` geometries.\n- **Cholera History:** Time-series data of cases linked to LGAs.\n\n### The Risk Scoring Engine\n\nWhen new satellite data comes in, we trigger a risk calculation job. This isn't just a simple overlap; it's a weighted multi-factor model:\n\n$$ \\text{Risk Score} = (w_1 \\times \\text{FloodExtent}) + (w_2 \\times \\text{CaseVelocity}) + (w_3 \\times \\text{Vulnerability}) $$\n\nWhere:\n- **FloodExtent:** Percentage of the LGA's area currently inundated.\n- **CaseVelocity:** Rate of change in new cholera cases over the last 7 days.\n- **Vulnerability:** A static factor based on population density and historical susceptibility.\n\n### Spatial SQL in Action\n\nTo calculate the `FloodExtent`, we don't need to download the raster. We can perform vector-raster analysis or use simplified vector intersections if we convert the flood mask to polygons.\n\nHere's how we determine which health facilities are in danger zones using PostGIS:\n\n```sql\n-- Find health facilities within 1km of detected flood zones\nSELECT \n    hf.name, \n    hf.type,\n    lga.name as lga\nFROM \n    health_facilities hf\nJOIN \n    lgas lga ON hf.lga_id = lga.id\nWHERE \n    ST_DWithin(\n        hf.location, \n        ST_GeomFromGeoJSON(:flood_polygon_json), \n        1000 -- meters\n    );\n```\n\nThis query runs in milliseconds, allowing us to generate real-time alert lists for field teams.\n\n---\n\n## 4. Frontend Engineering: Performance at Scale\n\nVisualizing geospatial data on the web is notoriously resource-intensive. We used **Next.js** and **Leaflet**, but encountered several performance bottlenecks during development.\n\n### Challenge 1: Heavy GeoJSON Rendering\nRendering detailed boundaries for all LGAs caused main-thread blocking.\n**Solution:** We simplified the geometries using the **Douglas-Peucker algorithm** (via Mapshaper) to reduce vertex count by 90% without losing visual fidelity at zoom level 8-10. We also implemented `useMemo` hooks in React to prevent re-parsing the GeoJSON on every render.\n\n### Challenge 2: Dynamic Legend & Symbology\nUsers needed to understand the map at a glance.\n**Solution:** We implemented a Choropleth layer that dynamically recolors LGA polygons based on the live Risk Score.\n\n```typescript\n// Choropleth coloring logic\nfunction getStyle(riskLevel: string) {\n  return {\n    fillColor: riskLevel === 'high' ? '#ef4444' : \n               riskLevel === 'medium' ? '#eab308' : '#22c55e',\n    weight: 2,\n    opacity: 1,\n    color: 'white',\n    fillOpacity: 0.7\n  };\n}\n```\n\n### Challenge 3: Time-Travel Analysis\nWe built a **Time Slider** component that allows epidemiologists to \"replay\" the last 90 days. This required synchronizing two disparate data streams:\n1.  **Daily Case Counts:** Fetched from our API.\n2.  **Satellite Imagery:** Fetched dynamically from GEE.\n\nBy managing the `selectedDate` state in a global store (Zustand), we ensure that dragging the slider instantly updates both the chart overlays and the map layers, revealing the lag effect where case spikes often follow flood events by 3-5 days.\n\n---\n\n## 5. Deployment & CI/CD\n\nThe system is containerized with **Docker** for the backend and deployed on Vercel (frontend) and a VPS (backend/DB).\n\nWe use **GitHub Actions** for CI/CD, running:\n- **Linting:** Ruff (Python) and ESLint (JS).\n- **Type Checking:** Mypy and TypeScript.\n- **Migration Checks:** Alembic is used to manage database schema changes, ensuring our PostGIS extensions and geometry columns are correctly versioned.\n\n## Conclusion & Future Work\n\nThis project demonstrates the immense potential of combining **Remote Sensing** with **Modern Web Engineering**. By automating the ingestion and analysis of satellite data, we move from reactive \"cleanup\" to proactive \"early warning.\"\n\n**What's Next?**\n- **AI Prediction Models:** Training an LSTM neural network on the historical data to predict outbreaks 2 weeks in advance.\n- **SMS Alerts:** Integrating Twilio to send automated SMS warnings to health workers in high-risk LGAs.\n- **Drone Integration:** Allowing field teams to upload drone orthomosaics for hyper-local validation.\n\nThe stack—**Python, PostGIS, and Google Earth Engine**—has proved to be a robust, scalable foundation for building life-saving geospatial tools.\n\n---\n\n*Check out the code on [GitHub](https://github.com/Some19ice/flooding-cholera) or view the [Live Dashboard](https://flooding-cholera.vercel.app).*\n","readTime":"20 min read","title":"Building a Real-Time Flood Surveillance System with Satellite Imagery & PostGIS","date":"2026-01-26","excerpt":"A deep technical dive into architecting a disaster response platform. We explore integrating Google Earth Engine's petabyte-scale catalog with FastAPI, PostGIS, and React to predict cholera outbreaks in real-time.","coverImage":"/flood-cholera-dashboard.svg","tags":["GIS","System Architecture","Google Earth Engine","Python","React","PostGIS","Remote Sensing"]}},"__N_SSG":true}